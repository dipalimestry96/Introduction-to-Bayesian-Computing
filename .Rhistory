set.seed(123)
n = 50                                          # sample size
alpha = 8                                       # prior parameter
beta = 4                                        # prior parameter
lambda = rgamma(1,alpha,beta)                   # true lambda
lambda
y = rexp(n = n,rate = lambda)                   # data (simulated here)
p_alpha = alpha + n; p_alpha                    # posterior alpha
p_beta = (1/beta) + n*mean(y); p_beta           # posterior beta
p_mean = p_alpha/p_beta; p_mean                 # exact posterior mean
par(mfrow=c(2,3))
M = c(100,500,1000)
for (m in M) {
z1 = rgamma(n=m, shape=p_alpha, rate=p_beta)
hist(z1, probability = TRUE,main=paste("m =",m),
xlab=expression(lambda),col = "light grey")
curve(dgamma(x, shape = p_alpha, rate = p_beta),
col ="blue", add=TRUE, lwd = 2)
points(lambda, 0, pch = 19,col = "red", cex = 2)
set.seed(123)
n = 50                                          # sample size
alpha = 8                                       # prior parameter
beta = 4                                        # prior parameter
lambda = rgamma(1,alpha,beta)                   # true lambda
lambda
y = rexp(n = n,rate = lambda)                   # data (simulated here)
p_alpha = alpha + n; p_alpha                    # posterior alpha
p_beta = (1/beta) + n*mean(y); p_beta           # posterior beta
p_mean = p_alpha/p_beta; p_mean                 # exact posterior mean
par(mfrow=c(2,3))
M = c(100,500,1000)
for (m in M) {
hist(z1, probability = TRUE,main=paste("m =",m),
xlab=expression(lambda),col = "light grey")
}
set.seed(123)
n = 50                                          # sample size
alpha = 8                                       # prior parameter
beta = 4                                        # prior parameter
lambda = rgamma(1,alpha,beta)                   # true lambda
lambda
y = rexp(n = n,rate = lambda)                   # data (simulated here)
p_alpha = alpha + n; p_alpha                    # posterior alpha
p_beta = (1/beta) + n*mean(y); p_beta           # posterior beta
p_mean = p_alpha/p_beta; p_mean                 # exact posterior mean
par(mfrow=c(2,3))
M = c(100,500,1000)
for (m in M) {
z1 = rgamma(n=m, shape=p_alpha, rate=p_beta)
hist(z1, probability = TRUE,main=paste("m =",m),
xlab=expression(lambda),col = "light grey")
curve(dgamma(x, shape = p_alpha, rate = p_beta),
col ="blue", add=TRUE, lwd = 2)
points(lambda, 0, pch = 19,col = "red", cex = 2)}
set.seed(123)
n = 50                                          # sample size
alpha = 8                                       # prior parameter
beta = 4                                        # prior parameter
lambda = rgamma(1,alpha,beta)                   # true lambda
lambda
y = rexp(n = n,rate = lambda)                   # data (simulated here)
p_alpha = alpha + n; p_alpha                    # posterior alpha
p_beta = (1/beta) + n*mean(y); p_beta           # posterior beta
p_mean = p_alpha/p_beta; p_mean                 # exact posterior mean
par(mfrow=c(1,3))
M = c(100,500,1000)
for (m in M) {
z1 = rgamma(n=m, shape=p_alpha, rate=p_beta)
hist(z1, probability = TRUE,main=paste("m =",m),
xlab=expression(lambda),col = "light grey")
curve(dgamma(x, shape = p_alpha, rate = p_beta),
col ="blue", add=TRUE, lwd = 2)
points(lambda, 0, pch = 19,col = "red", cex = 2)}
hist(z1, probability = TRUE,main=paste("m =",m),
xlab=expression(lambda),col = "light grey", cex.lab = 1.5)
set.seed(123)
n = 50                                          # sample size
alpha = 8                                       # prior parameter
beta = 4                                        # prior parameter
lambda = rgamma(1,alpha,beta)                   # true lambda
lambda
y = rexp(n = n,rate = lambda)                   # data (simulated here)
p_alpha = alpha + n; p_alpha                    # posterior alpha
p_beta = (1/beta) + n*mean(y); p_beta           # posterior beta
p_mean = p_alpha/p_beta; p_mean                 # exact posterior mean
par(mfrow=c(1,3))
M = c(100,500,1000)
for (m in M) {
z1 = rgamma(n=m, shape=p_alpha, rate=p_beta)
hist(z1, probability = TRUE,main=paste("m =",m),
xlab=expression(lambda),col = "light grey", cex.lab = 1.5)
curve(dgamma(x, shape = p_alpha, rate = p_beta),
col ="blue", add=TRUE, lwd = 2)
points(lambda, 0, pch = 19,col = "red", cex = 2)}
hist(z1, probability = TRUE,main=paste("m =",m),
xlab=expression(lambda),col = "light grey", cex.lab = 1.5, cex.main = 2)
for (m in M) {
z1 = rgamma(n=m, shape=p_alpha, rate=p_beta)
hist(z1, probability = TRUE,main=paste("m =",m),
xlab=expression(lambda),col = "light grey", cex.lab = 1.5, cex.main = 1.5)
curve(dgamma(x, shape = p_alpha, rate = p_beta),
col ="blue", add=TRUE, lwd = 2)
points(lambda, 0, pch = 19,col = "red", cex = 2)}
for (m in M) {
z1 = rgamma(n=m, shape=p_alpha, rate=p_beta)
hist(z1, probability = TRUE,main=paste("m =",m),
xlab=expression(lambda),col = "light grey", cex.lab = 1.5, cex.main = 1.5)
curve(dgamma(x, shape = p_alpha, rate = p_beta),
col ="blue", add=TRUE, lwd = 2)
points(lambda, 0, pch = 19,col = "red", cex = 2)}
set.seed(123)
n = 50                                          # sample size
alpha = 8                                       # prior parameter
beta = 4                                        # prior parameter
lambda = rgamma(1,alpha,beta)                   # true lambda
lambda
y = rexp(n = n,rate = lambda)                   # data (simulated here)
p_alpha = alpha + n; p_alpha                    # posterior alpha
p_beta = (1/beta) + n*mean(y); p_beta           # posterior beta
p_mean = p_alpha/p_beta; p_mean                 # exact posterior mean
par(mfrow=c(1,3))
M = c(100,500,1000)
for (m in M) {
z1 = rgamma(n=m, shape=p_alpha, rate=p_beta)
hist(z1, probability = TRUE,main=paste("m =",m),
xlab=expression(lambda),col = "light grey", cex.lab = 1.5, cex.main = 1.5)
curve(dgamma(x, shape = p_alpha, rate = p_beta),
col ="blue", add=TRUE, lwd = 2)
points(lambda, 0, pch = 19,col = "red", cex = 2)}
beta_0 = 3                                 # population intercept
beta_1 = 1                                 # population slope
phi = 1                                    # population error variance
x = seq(1, 5, length.out = 50)             # fixation of the population parameter
set.seed(123)                              # we fixing a randomness in output
y = beta_0 + beta_1 * x + rnorm(length(x), 0, sqrt(phi))
data = data.frame(y, x)                    # data containing population size
plot(x,y, col = "red")
plot(x,y, col = "red", pch = 19)
beta_0 = 3                                 # population intercept
beta_1 = 1                                 # population slope
phi = 1                                    # population error variance
x = seq(1, 5, length.out = 50)             # fixation of the population parameter
set.seed(123)                              # we fixing a randomness in output
y = beta_0 + beta_1 * x + rnorm(length(x), 0, sqrt(phi))
data = data.frame(y, x)                    # data containing population size
plot(x,y, col = "red", pch = 19)
# Prior for beta_0
mu_0 = 2; tau_0 = 0.4                      # prior parameter
prior_beta_0 = function(x){                # function for prior beta_1
dnorm(x, mean = mu_0, sd = sqrt(tau_0))
}
# Prior for beta_1
mu_1 = 2; tau_1 = 0.5                      # prior parameter
prior_beta_1 = function(x){                # function for prior beta_1
dnorm(x, mean = mu_1, sd = sqrt(tau_1))
}
# Prior for phi.
library(invgamma)                          #
alpha = 2; gamma = 2                       # prior parameters
prior_phi = function(x){                   # function for prior phi
dinvgamma(x, shape = alpha, rate = gamma)
}
likelihood = function(data, params){   # likelihood function of data given parameters
y = data[,1]
x = data[,2]
n = nrow(data)
beta_0 = params[1]
beta_1 = params[2]
phi = params[3]
log_lik = -n*log(sqrt(2*pi)) - (n/2)*log(phi) - sum((y - beta_0-beta_1*x)^2)/(2*phi)
# log-likelihood of data given parameters
return(exp(log_lik))
}
# storage for posterior samples
iteration = 100000                        # number of iterations
post_beta_0 = rep(NA, iteration)          # storage for posterior of beta_0
post_beta_1 = rep(NA, iteration)          # storage for posterior of beta_1
post_phi = rep(NA, iteration)             # storage for posterior of phi
# Specification of grids
step = 0.01                                      # grid step
grid_beta_0 = seq(from = -5, to = 10, by = step) # fixation of the grid of beta_0
grid_beta_1 = seq(from = -5, to = 5, by = step)  # fixation of the grid of beta_1
# Initialization of the posterior samples
post_beta_0[1] = rnorm(1, mean = mu_0, sd = sqrt(tau_0))   # posterior beta_0
post_beta_1[1] = rnorm(1, mean = mu_1, sd = sqrt(tau_1))   # posterior beta_1
post_phi[1] = rinvgamma(n = 1, shape = alpha, rate = gamma)# posterior phi
for(i in 2:iteration){
# section for posterior sample of beta_0
tmp_post_beta_0 = rep(NA, length(grid_beta_0))
for(j in 1:length(grid_beta_0)){
params = c(grid_beta_0[j], post_beta_1[i-1], post_phi[i-1])
tmp_post_beta_0[j] = likelihood(data = data, params = params)
* prior_beta_0(grid_beta_0[j])
# Trace plots
par(mfrow = c(2,2))
# trace plot of posterior of beta_0
plot(post_beta_0, type = "l", main = bquote("Trace plot of"~ beta[0]),col = "red")
# trace plot of posterior of beta_1
plot(post_beta_1, type = "l", main = bquote("Trace plot of"~ beta[1]),col = "red")
# trace plot of posterior of phi
plot(post_phi, type = "l", main = bquote("Trace plot of"~ phi),col = "red")
grid_beta_0 = seq(from = -5, to = 10, by = step) # fixation of the grid of beta_0
grid_beta_1 = seq(from = -5, to = 5, by = step)  # fixation of the grid of beta_1
# Initialization of the posterior samples
post_beta_0[1] = rnorm(1, mean = mu_0, sd = sqrt(tau_0))   # posterior beta_0
post_beta_1[1] = rnorm(1, mean = mu_1, sd = sqrt(tau_1))   # posterior beta_1
post_phi[1] = rinvgamma(n = 1, shape = alpha, rate = gamma)# posterior phi
for(i in 2:iteration){
# section for posterior sample of beta_0
tmp_post_beta_0 = rep(NA, length(grid_beta_0))
for(j in 1:length(grid_beta_0)){
params = c(grid_beta_0[j], post_beta_1[i-1], post_phi[i-1])
tmp_post_beta_0[j] = likelihood(data = data, params = params)
* prior_beta_0(grid_beta_0[j])
for(i in 2:iteration){
# section for posterior sample of beta_0
tmp_post_beta_0 = rep(NA, length(grid_beta_0))
for(j in 1:length(grid_beta_0)){
params = c(grid_beta_0[j], post_beta_1[i-1], post_phi[i-1])
tmp_post_beta_0[j] = likelihood(data = data, params = params)* prior_beta_0(grid_beta_0[j])
}
prob = tmp_post_beta_0/sum(tmp_post_beta_0)
post_beta_0[i] = sample(grid_beta_0, 1, prob = prob) # sample of posterior
beta_0 after normalize
for(i in 2:iteration){
# section for posterior sample of beta_0
tmp_post_beta_0 = rep(NA, length(grid_beta_0))
for(j in 1:length(grid_beta_0)){
params = c(grid_beta_0[j], post_beta_1[i-1], post_phi[i-1])
tmp_post_beta_0[j] = likelihood(data = data, params = params)* prior_beta_0(grid_beta_0[j])
}
prob = tmp_post_beta_0/sum(tmp_post_beta_0)
post_beta_0[i] = sample(grid_beta_0, 1, prob = prob) # sample of posterior beta_0 after normalize
# section for posterior sample of beta_1
tmp_post_beta_1 = rep(NA, length(grid_beta_1))
for(j in 1:length(grid_beta_1)){
params = c(post_beta_0[i], grid_beta_1[j], post_phi[i-1])
tmp_post_beta_1[j] = likelihood(data = data, params= params)* prior_beta_1(grid_beta_1[j])
}
prob = tmp_post_beta_1/(sum(tmp_post_beta_1))
post_beta_1[i] = sample(grid_beta_1, 1, prob = prob) # sample of posterior beta_1 after normalize
# section for posterior sample of phi
shape = alpha + nrow(data)/2
rate = (1/2)*sum((y - post_beta_0[i] - post_beta_1[i]*x)^2) + gamma
post_phi[i] = rinvgamma(1, shape = shape, rate = rate)  # sample of posterior phi
}
for(i in 2:iteration){
print(i)
# section for posterior sample of beta_0
tmp_post_beta_0 = rep(NA, length(grid_beta_0))
for(j in 1:length(grid_beta_0)){
params = c(grid_beta_0[j], post_beta_1[i-1], post_phi[i-1])
tmp_post_beta_0[j] = likelihood(data = data, params = params)* prior_beta_0(grid_beta_0[j])
}
prob = tmp_post_beta_0/sum(tmp_post_beta_0)
post_beta_0[i] = sample(grid_beta_0, 1, prob = prob) # sample of posterior beta_0 after normalize
# section for posterior sample of beta_1
tmp_post_beta_1 = rep(NA, length(grid_beta_1))
for(j in 1:length(grid_beta_1)){
params = c(post_beta_0[i], grid_beta_1[j], post_phi[i-1])
tmp_post_beta_1[j] = likelihood(data = data, params= params)* prior_beta_1(grid_beta_1[j])
}
prob = tmp_post_beta_1/(sum(tmp_post_beta_1))
post_beta_1[i] = sample(grid_beta_1, 1, prob = prob) # sample of posterior beta_1 after normalize
# section for posterior sample of phi
shape = alpha + nrow(data)/2
rate = (1/2)*sum((y - post_beta_0[i] - post_beta_1[i]*x)^2) + gamma
post_phi[i] = rinvgamma(1, shape = shape, rate = rate)  # sample of posterior phi
}
# Trace plots
par(mfrow = c(1,3))
# trace plot of posterior of beta_0
plot(post_beta_0, type = "l", main = bquote("Trace plot of"~ beta[0]),col = "red")
# trace plot of posterior of beta_1
plot(post_beta_1, type = "l", main = bquote("Trace plot of"~ beta[1]),col = "red")
# trace plot of posterior of phi
plot(post_phi, type = "l", main = bquote("Trace plot of"~ phi),col = "red")
# trace plot of posterior of beta_0
plot(post_beta_0, type = "l", main = bquote("Trace plot of"~ beta[0]),col = "red", cex.main = 1.5)
# trace plot of posterior of beta_0
plot(post_beta_0, type = "l", main = bquote("Trace plot of"~ beta[0]),col = "red", cex.main = 1.5, ylab = bquote(beta[0]))
# trace plot of posterior of beta_0
plot(post_beta_0, type = "l", main = bquote("Trace plot of"~ beta[0]),col = "red", cex.main = 1.5, ylab = bquote(beta[0]), cex.axis = 1.5)
# trace plot of posterior of beta_0
plot(post_beta_0, type = "l", main = bquote("Trace plot of"~ beta[0]),col = "red", cex.main = 1.5, ylab = bquote(beta[0]), cex.lab = 1.5)
# trace plot of posterior of beta_0
plot(post_beta_0, type = "l", main = bquote("Trace plot of"~ beta[0]),col = "red", cex.main = 1.5, ylab = bquote(beta[0]), cex.lab = 1.2)
# Trace plots
par(mfrow = c(1,3))
# trace plot of posterior of beta_0
plot(post_beta_0, type = "l", main = bquote("Trace plot of"~ beta[0]),col = "red", cex.main = 1.5, ylab = bquote(beta[0]), cex.lab = 1.2)
# trace plot of posterior of beta_1
plot(post_beta_1, type = "l", main = bquote("Trace plot of"~ beta[1]),col = "red", cex.main = 1.5, ylab = bquote(beta[0]), cex.lab = 1.2)
# Trace plots
par(mfrow = c(1,3))
# trace plot of posterior of beta_0
plot(post_beta_0, type = "l", main = bquote("Trace plot of"~ beta[0]),col = "red", cex.main = 1.5, ylab = bquote(beta[0]), cex.lab = 1.2)
# trace plot of posterior of beta_1
plot(post_beta_1, type = "l", main = bquote("Trace plot of"~ beta[1]),col = "red", cex.main = 1.5, ylab = bquote(beta[1]), cex.lab = 1.2)
# trace plot of posterior of phi
plot(post_phi, type = "l", main = bquote("Trace plot of"~ phi),col = "red", cex.main = 1.5, ylab = bquote(phi), cex.lab = 1.2)
# Trace plots
par(mfrow = c(1,3))
# trace plot of posterior of beta_0
plot(post_beta_0, type = "l", main = bquote("Trace plot of"~ beta[0]),col = "red", cex.main = 1.5, ylab = bquote(beta[0]), cex.lab = 1.2)
# trace plot of posterior of beta_1
plot(post_beta_1, type = "l", main = bquote("Trace plot of"~ beta[1]),col = "red", cex.main = 1.5, ylab = bquote(beta[1]), cex.lab = 1.2)
# trace plot of posterior of phi
plot(post_phi, type = "l", main = bquote("Trace plot of"~ phi),col = "red", cex.main = 1.5, ylab = bquote(phi), cex.lab = 1.2)
par(mfrow=c(1,3))
alpha = 4; beta = 1/2;
lambda = seq(0.1, 5, length.out = 50)
n_vals = c(10, 25, 50)
for(n in n_vals){
mse_lambda_cap = lambda/n
mse_lambdaB_cap = (beta^2*n*lambda + (alpha*beta-lambda)^2)/(n*beta+1)^2
plot(lambda, mse_lambda_cap, col = "red", lwd=3, lty=1, type="l",
xlab = expression(lambda), cex.lab = 1.2, ylab = "MSE", main = paste("n = ", n))
lines(lambda, mse_lambdaB_cap, col = "blue", lwd=3, lty=1)
legend = c( expression(paste("MSE"[lambda], (hat(lambda)))),
expression(paste("MSE"[lambda], (hat(lambda)[B]))))
legend("topleft",legend = legend, lwd = c(3,3),col = c("red","blue"),
lty = c(1,1), cex = 0.8, bty = "n")
points(alpha*beta, 0, lwd=2, pch=20, cex=2)
}
par(mfrow=c(1,3))
alpha = 4; beta = 1/2;
lambda = seq(0.1, 5, length.out = 50)
n_vals = c(10, 25, 50)
for(n in n_vals){
mse_lambda_cap = lambda/n
mse_lambdaB_cap = (beta^2*n*lambda + (alpha*beta-lambda)^2)/(n*beta+1)^2
plot(lambda, mse_lambda_cap, col = "red", lwd=3, lty=1, type="l",
xlab = expression(lambda), cex.lab = 1.2, ylab = "MSE", main = paste("n = ", n))
lines(lambda, mse_lambdaB_cap, col = "blue", lwd=3, lty=1)
legend = c( expression(paste("MSE"[lambda], (hat(lambda)))),
expression(paste("MSE"[lambda], (hat(lambda)[B]))))
legend("topleft",legend = legend, lwd = c(3,3),col = c("red","blue"),
lty = c(1,1), cex = 0.8, bty = "n")
points(alpha*beta, 0, lwd=2, pch=20, cex=2)
}
for(n in n_vals){
mse_lambda_cap = lambda/n
mse_lambdaB_cap = (beta^2*n*lambda + (alpha*beta-lambda)^2)/(n*beta+1)^2
plot(lambda, mse_lambda_cap, col = "red", lwd=3, lty=1, type="l",
xlab = expression(lambda), cex.lab = 1.2, ylab = "MSE", main = paste("n = ", n))
lines(lambda, mse_lambdaB_cap, col = "blue", lwd=3, lty=1)
legend = c( expression(paste("MSE"[lambda], (hat(lambda)))),
expression(paste("MSE"[lambda], (hat(lambda)[B]))))
legend("topleft",legend = legend, lwd = c(3,3),col = c("red","blue"),
lty = c(1,1), cex = 1, bty = "n")
points(alpha*beta, 0, lwd=2, pch=20, cex=2)
}
for(n in n_vals){
mse_lambda_cap = lambda/n
mse_lambdaB_cap = (beta^2*n*lambda + (alpha*beta-lambda)^2)/(n*beta+1)^2
plot(lambda, mse_lambda_cap, col = "red", lwd=3, lty=1, type="l",
xlab = expression(lambda), cex.lab = 1.2, ylab = "MSE", main = paste("n = ", n), cex.main = 1.5)
lines(lambda, mse_lambdaB_cap, col = "blue", lwd=3, lty=1)
legend = c( expression(paste("MSE"[lambda], (hat(lambda)))),
expression(paste("MSE"[lambda], (hat(lambda)[B]))))
legend("topleft",legend = legend, lwd = c(3,3),col = c("red","blue"),
lty = c(1,1), cex = 1, bty = "n")
points(alpha*beta, 0, lwd=2, pch=20, cex=2)
}
plot(lambda, mse_lambda_cap, col = "red", lwd=3, lty=1, type="l",
xlab = expression(lambda), cex.lab = 1.2, ylab = "MSE", main = paste("n = ", n), cex.main = 1.5, cex.lab = 1.5)
for(n in n_vals){
mse_lambda_cap = lambda/n
mse_lambdaB_cap = (beta^2*n*lambda + (alpha*beta-lambda)^2)/(n*beta+1)^2
plot(lambda, mse_lambda_cap, col = "red", lwd=3, lty=1, type="l",
xlab = expression(lambda), cex.lab = 1.2, ylab = "MSE", main = paste("n = ", n), cex.main = 1.5, cex.lab = 1.5)
lines(lambda, mse_lambdaB_cap, col = "blue", lwd=3, lty=1)
legend = c( expression(paste("MSE"[lambda], (hat(lambda)))),
expression(paste("MSE"[lambda], (hat(lambda)[B]))))
legend("topleft",legend = legend, lwd = c(3,3),col = c("red","blue"),
lty = c(1,1), cex = 1, bty = "n")
points(alpha*beta, 0, lwd=2, pch=20, cex=2)
}
par(mfrow=c(1,3))
alpha = 4; beta = 1/2;
lambda = seq(0.1, 5, length.out = 50)
n_vals = c(10, 25, 50)
for(n in n_vals){
mse_lambda_cap = lambda/n
mse_lambdaB_cap = (beta^2*n*lambda + (alpha*beta-lambda)^2)/(n*beta+1)^2
plot(lambda, mse_lambda_cap, col = "red", lwd=3, lty=1, type="l",
xlab = expression(lambda), cex.lab = 1.2, ylab = "MSE", main = paste("n = ", n), cex.main = 1.5, cex.lab = 1.5)
lines(lambda, mse_lambdaB_cap, col = "blue", lwd=3, lty=1)
legend = c( expression(paste("MSE"[lambda], (hat(lambda)))),
expression(paste("MSE"[lambda], (hat(lambda)[B]))))
legend("topleft",legend = legend, lwd = c(3,3),col = c("red","blue"),
lty = c(1,1), cex = 1, bty = "n")
points(alpha*beta, 0, lwd=2, pch=20, cex=2)
}
citation(rnvgamma)
citation(invgamma)
library(invgamma)
citation(invgamma)
install.packages("invgamma")
library(invgamma)
citation("invgamma")
citation("BayesReg")
install.packages("bayesreg")
install.packages("rstanarm")
install.packages("brms")
library(brms)
citation(brms)
library(rstanarm)
citation("rstanarm")
library(bayesreg)
library(BayesReg)
citation(bayesreg())
citation(bayesreg)
citation("bayesreg")
citation(MASS)
citation("MASS")
citation("ISLR")
citation(leaps)
citation("leaps")
install.packages("leaps")
library(leaps)
citation(leaps)
citation("leaps")
rm = 0.5 # intrinsic growth rate
theta = 0.5 # parameter for strength of density dependence
K = 50 # carrying capacity of the environment
sig_2e = 0.0025 # variance of the environmental perturbation
n = 30 # length of the time series = n+1
N1 = 23 # initial population size
set.seed(471)
N = numeric(n + 1) # storage the simulated time series
N[1] = N1 # initial population size.
for(i in 1:(length(N)-1)){
r = rnorm(n =1, mean = rm*(1-(N[i]/K)^theta), sd = sqrt(sig_2e)) #   simulating growth rate
N[i+1] = N[i]*exp(r) # simulate next generation
}
#print(N) # printing population size
plot(1:(n+1), N, type= "p", lwd=2, col = "red")
fun_logistic = function(x){ # Deterministic solution of the generalized logistic equation
K/(1+((K/N1)^theta-1 )*exp(-rm*x*theta) )^(1/theta)
}
curve(fun_logistic, 0, n+1, add= TRUE, lwd=2)
rm = 0.5 # intrinsic growth rate
theta = 0.5 # parameter for strength of density dependence
K = 50 # carrying capacity of the environment
sig_2e = 0.0025 # variance of the environmental perturbation
n = 30 # length of the time series = n+1
N1 = 23 # initial population size
set.seed(471)
N = numeric(n + 1) # storage the simulated time series
N[1] = N1 # initial population size.
for(i in 1:(length(N)-1)){
r = rnorm(n =1, mean = rm*(1-(N[i]/K)^theta), sd = sqrt(sig_2e)) #   simulating growth rate
N[i+1] = N[i]*exp(r) # simulate next generation
}
#print(N) # printing population size
plot(1:(n+1), N, type= "p", lwd=2, col = "red", pch = 19)
fun_logistic = function(x){ # Deterministic solution of the generalized logistic equation
K/(1+((K/N1)^theta-1 )*exp(-rm*x*theta) )^(1/theta)
}
curve(fun_logistic, 0, n+1, add= TRUE, lwd=2)
# prior for rm
prior_mean_rm = coef(fit)[1]
deno upgrade
